import createClient, { Client } from 'openapi-fetch';
import { authMiddleware } from './auth';
import { NerisApiConfig } from './config';
import type { components, paths } from './neris-api'; // generated by openapi-typescript

let apiUrl = process.env.NERIS_BASE_URL || 'https://api.neris.fsri.org/v1';
let userAgent = process.env.NERIS_USER_AGENT || 'NerisAPIClient/1.1.0 (Node.js)';

let setHeaders = {
  'User-Agent': userAgent
};

export const defaultConfig = (): NerisApiConfig => {
  switch (process.env.NERIS_GRANT_TYPE) {
    case 'password':
      return {
        baseUrl: apiUrl,
        auth: {
          _type: 'password',
          username: process.env.NERIS_USERNAME || '',
          password: process.env.NERIS_PASSWORD || '',
        },
        headers: setHeaders
      };
    case 'client_credentials':
      return {
        baseUrl: apiUrl,
        auth: {
          _type: 'client_credentials',
          client_id: process.env.NERIS_CLIENT_ID || '',
          client_secret: process.env.NERIS_CLIENT_SECRET || '',
        },
        headers: setHeaders
      };
    default:
      throw new Error("Bad grant_type. Options are 'client_credentials', or 'password'.");
  }
};

export type NerisClient = Client<paths> & {
  fetchGeometry: (url: URL) => Promise<components['schemas']['GeoJsonMultiPolygon']>;
};

export const createNerisClient = (config: NerisApiConfig = defaultConfig()): NerisClient => {
  const client = createClient<paths>({
    baseUrl: config.baseUrl,
    fetch: config.fetch,
    headers: config.headers
  });
  const auth = authMiddleware(config);
  client.use(auth);

  return {
    ...client,
    fetchGeometry: async (url: URL) => {
      let req = new Request(url);

      if (auth.onRequest) {
        req = (await auth.onRequest({ request: req } as any)) || req;
      }

      const res = await fetch(req);

      if (res.status !== 200) {
        throw new Error(`fetchGeometry failed. status: ${res.status}: ${res.statusText}`);
      }

      const data = await res.json();

      if (data.geometry?.type === 'MultiPolygon' && Array.isArray(data.geometry?.coordinates)) {
        return {
          type: 'MultiPolygon',
          coordinates: data.geometry?.coordinates,
        };
      }

      throw new Error('fetchGeometry failed. geojson was not valid');
    },
  };
};
